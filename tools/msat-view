#!/usr/bin/python3

# Copyright (C) 2010--2012  ARPA-SIM <urpsim@smr.arpa.emr.it>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
#
# Author: Enrico Zini <enrico@enricozini.com>

from typing import Optional, Tuple
import math

VERSION = "0.3"


def start_app(args):
    # All the Gtk-dependent code is here to be able to print command-line help
    # even when the needed python modules are not installed
    import gdal
    import osr
    import gi
    from gi.repository import GObject
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk
    from gi.repository import Gdk
    # from gi.repository import GdkPixbuf
    import cairo
    import numpy

#    class ImagePosition:
#        def __init__(self, px, py, lat, lon):
#            self.px = px
#            self.py = py
#            self.lat = lat
#            self.lon = lon
#
#    class ImageArea:
#        def __init__(self, pos1, pos2):
#            self.pos1 = pos1
#            self.pos2 = pos2

    class MapWidget(Gtk.DrawingArea):
        __gtype_name__ = "MapWidget"
        __gsignals__ = {
                "area-changed": (GObject.SignalFlags.RUN_FIRST, GObject.TYPE_NONE, (object,)),
                "position-changed": (GObject.SignalFlags.RUN_FIRST, GObject.TYPE_NONE, (object,)),
        }

        def __init__(self):
            super().__init__()
            self.add_events(Gdk.EventMask.POINTER_MOTION_MASK
                            | Gdk.EventMask.BUTTON_PRESS_MASK
                            | Gdk.EventMask.BUTTON_RELEASE_MASK)

            # GDAL dataset for the current image
            self.dataset = None
            # GDAL RasterBand currently displayed
            self.raster_band = None
            # Projection of the image currently displayed
            self.proj = osr.SpatialReference()
            # Coordinate transformation to georeference image points
            self.to_latlon = None
            # Geotransform matrix to georeference image points
            self.geotrans = None
            # Cached image
            # self.cached_img: Optional[Gdk.Pixbuf] = None
            self.cached_img: Optional[cairo.ImageSurface] = None
            # Pending timer for an image rescale
            self.refresh_timeout = None
#
#            self.rect = None
#            self.rect_origin = None
            # Aspect ratio of the current image
            self.aspect: float = 1.0
            self.zoom: Optional[Gdk.Rectangle] = None

            # self.connect("draw", self.do_draw)

        def load(self, fname):
            self.dataset = gdal.Open(fname, gdal.GA_ReadOnly)
            self.raster_band = self.dataset.GetRasterBand(1)
            self.proj.SetFromUserInput(self.dataset.GetProjectionRef())
            proj_latlon = self.proj.CloneGeogCS()
            self.to_latlon = osr.CoordinateTransformation(self.proj, proj_latlon)
            self.geotrans = self.dataset.GetGeoTransform()
            self.cached_img = None
            self.aspect = self.raster_band.XSize / self.raster_band.YSize

#            self.paintedsize = None

        def do_draw(self, context):
            """
            Called by Gtk when the widget needs to redraw itself
            """
            allocation = self.get_allocation()

            width, height = self.enforce_aspect_ratio(allocation.width, allocation.height)
            # Uncomment to center the image
            # context.translate((allocation.width - width) / 2, (allocation.height - height) / 2)
            img = self.render_image(width, height)
            if img.get_width() != width or img.get_height() != height:
                bigger = img.get_width() < width or img.get_height() < height
                # Scale the context to fit the image to the widget
                context.scale(width / img.get_width(), height / img.get_height())
                if bigger:
                    # Only regenerate image if we need more resolution
                    self.schedule_refresh()

            # TODO: look into https://pycairo.readthedocs.io/en/latest/reference/patterns.html#class-rastersourcepattern-pattern ?  # noqa
            context.set_source(cairo.SurfacePattern(img))
            context.rectangle(0, 0, img.get_width(), img.get_height())
            context.fill()

#            # Draw selection rectangle
#            if self.rect:
#                # Reset cairo transform first?
#                self.get_window().draw_rectangle(self.get_style().fg_gc[Gtk.STATE_NORMAL], False, *self.rect)

        def render_image(self, width, height):
            if self.cached_img:
                return self.cached_img

            if self.zoom:
                data = self.raster_band.ReadRaster(
                        self.zoom.x, self.zoom.y, self.zoom.width, self.zoom.height, width, height, gdal.GDT_Byte)
            else:
                data = self.raster_band.ReadRaster(
                        xoff=0, yoff=0,
                        xsize=self.raster_band.XSize, ysize=self.raster_band.YSize,
                        buf_xsize=width, buf_ysize=height,
                        buf_type=gdal.GDT_Byte)

            # Normalise image data
            # import time
            # start = time.perf_counter()
            if True:
                # Numpy version, faster
                stride = cairo.ImageSurface.format_stride_for_width(cairo.Format.RGB24, width)
                stride_pad = stride - (width * 3)
                arr = numpy.fromstring(data, dtype=numpy.uint8).reshape((height, width))
                dmin = arr.min()
                dmax = arr.max()
                arr -= dmin
                numpy.multiply(arr, (255 / (dmax - dmin)), out=arr, casting="unsafe")
                arr = arr.repeat(3, axis=1)
                arr = numpy.pad(arr, ((0, 0), (0, stride_pad)), mode='constant')
                data = bytearray(arr.tobytes())
            else:
                stride = cairo.ImageSurface.format_stride_for_width(cairo.Format.RGB24, width)
                stride_pad = bytearray(stride - (width * 3))
                image_data = bytearray()
                dmin = min(data)
                dmax = max(data)
                scale = 255 / (dmax - dmin)
                data = memoryview(data)
                for row in range(height):
                    for d in data[row * width: (row + 1) * width]:
                        scaled = math.floor((d - dmin) * scale)
                        image_data.append(scaled)
                        image_data.append(scaled)
                        image_data.append(scaled)
                    image_data += stride_pad
                data = image_data
            # elapsed = time.perf_counter() - start
            # print("ELAPSED", elapsed)

            # print(f"min {dmin} → {min(data)}, max {dmax} → {max(data)}  [{width*height*3} {len(data)}]")

            self.cached_img = cairo.ImageSurface.create_for_data(data, cairo.Format.RGB24, width, height)
            return self.cached_img

        def enforce_aspect_ratio(self, w: int, h: int) -> Tuple[int, int]:
            """
            Take an arbitrary image size, and update it to match the current
            aspect ratio in self.aspect
            """
            nh = w / self.aspect
            nw = h * self.aspect
            if nh > h:
                w = nw
            elif nw > w:
                h = nh
            return round(w), round(h)

        def schedule_refresh(self):
            """
            Schedule a redraw without a cached image, after a timeout.

            This is used to trigger drawing a higher resolution of the current
            image, and to coalesce together multiple requests coming in a burst
            """
            if self.refresh_timeout:
                GObject.source_remove(self.refresh_timeout)
                self.refresh_timeout = None

            def refresh_image():
                self.cached_img = None
                self.queue_draw()
                return False

            self.refresh_timeout = GObject.timeout_add(1000, refresh_image)

#        def do_size_request(self, requisition):
#            # The do_size_request method Gtk+ is calling on a widget to ask
#            # it the widget how large it wishes to be. It's not guaranteed
#            # that gtk+ will actually give this size to the widget
#
#            # In this case, we say that we want to be as big as the
#            # text is, plus a little border around it.
#            # width, height = self._layout.get_size()
#            w, h = self.enforce_aspect_ratio(requisition.width, requisition.height)
#
#            requisition.width = w  # // pango.SCALE + BORDER_WIDTH*4
#            requisition.height = h  # // pango.SCALE + BORDER_WIDTH*4
#
#        def do_size_allocate(self, allocation):
#            # The do_size_allocate is called by when the actual size is known
#            # and the widget is told how much space could actually be allocated
#
#            # Save the allocated space
#            self.allocation = allocation
#
#            # If we're realized, move and resize the window to the
#            # requested coordinates/positions
#            if self.get_realized():
#                self.get_window().move_resize(allocation.x, allocation.y, allocation.width, allocation.height)
#                # self.cached_img = None
#
#        def update_rect(self, event):
#            rx = min(self.rect_origin[0], event.x)
#            ry = min(self.rect_origin[1], event.y)
#            rw = abs(self.rect_origin[0] - event.x)
#            rh = abs(self.rect_origin[1] - event.y)
#            if rx < 0:
#                rw += rx
#                rx = 0
#            if ry < 0:
#                rh += ry
#                ry = 0
#            if rx + rw >= self.paintedsize[0]:
#                rw = self.paintedsize[0] - rx - 1
#            if ry + rh >= self.paintedsize[1]:
#                rh = self.paintedsize[1] - ry - 1
#            self.rect = (int(rx), int(ry), int(rw), int(rh))
#
#            imgx, imgy = self.to_pixel_coords(rx, ry)
#            lat, lon = self.georeference(imgx, imgy)
#            p1 = ImagePosition(imgx, imgy, lat, lon)
#            imgx, imgy = self.to_pixel_coords(rx + rw, ry + rh)
#            lat, lon = self.georeference(imgx, imgy)
#            p2 = ImagePosition(imgx, imgy, lat, lon)
#
#            self.emit("area-changed", ImageArea(p1, p2))
#
#        def to_pixel_coords(self, x, y):
#            if self.zoom:
#                ix, iy, iw, ih = self.zoom
#            else:
#                ix, iy = 0, 0
#                iw = self.raster_band.XSize
#                ih = self.raster_band.YSize
#            imgx = ix + (x * iw / self.paintedsize[0])
#            imgy = iy + (y * ih / self.paintedsize[1])
#            if imgx >= self.raster_band.XSize:
#                imgx = self.raster_band.XSize
#            if imgy >= self.raster_band.YSize:
#                imgy = self.raster_band.YSize
#            return imgx, imgy
#
#        def do_motion_notify_event(self, event):
#            # x, y, w, h = self.allocation
#
#            # Extend rectangle if we are dragging
#            if event.state & Gdk.ModifierType.BUTTON1_MASK:
#                self.update_rect(event)
#                self.queue_draw()
#
#            # Convert to image pixels
#            imgx, imgy = self.to_pixel_coords(event.x, event.y)
#            lat, lon = self.georeference(imgx, imgy)
#            # print "(%d, %d) -> lat %f lon %f" % (imgx, imgy, lat, lon)
#            self.emit("position-changed", ImagePosition(imgx, imgy, lat, lon))
#
#            # TODO: Georeferentiate
#            return False
#
#        def georeference(self, x, y):
#            # Pixel coordinates to spaceview projected coordinates
#            px = self.geotrans[0] + self.geotrans[1] * x + self.geotrans[2] * y
#            py = self.geotrans[3] + self.geotrans[4] * x + self.geotrans[5] * y
#
#            # Projected coordinates to latlon
#            lon, lat = self.to_latlon.TransformPoint(px, py)[:2]
#            return lat, lon
#
#        def do_button_press_event(self, event):
#            x = min(self.paintedsize[0]-1, max(0, event.x))
#            y = min(self.paintedsize[0]-1, max(0, event.y))
#            self.rect = (int(x), int(y), 0, 0)
#            self.rect_origin = (int(x), int(y))
#            self.queue_draw()
#            return False
#
#        def do_button_release_event(self, event):
#            if not self.rect:
#                return False
#            self.update_rect(event)
#            self.queue_draw()
#            return False
#
#        def zoom_in(self, *args):
#            if self.rect:
#                self.cached_img = None
#                x1, y1 = self.to_pixel_coords(*self.rect[:2])
#                x2, y2 = self.to_pixel_coords(self.rect[0] + self.rect[2], self.rect[1] + self.rect[3])
#                self.zoom = (x1, y1, x2-x1, y2-y1)
#                self.queue_draw()
#
#        def zoom_out(self, *args):
#            if self.zoom:
#                self.cached_img = None
#                self.zoom = None
#                self.queue_draw()

    class ImageInfo(Gtk.Grid):
        def __init__(self):
            super().__init__()
            # n_rows=10, n_columns=2)
            self.attach(Gtk.Label(label="Position"), 0, 0, 2, 1)

            self.pos_pix = self.add_field("Pixels: ", 0, 1)
            self.pos_coord = self.add_field("Coords: ", 0, 2)

            self.attach(Gtk.Label(label="Area"), 0, 3, 2, 1)

            self.area_pix = self.add_field("Pixels: ", 0, 4)
            self.area_coord = self.add_field("Coords: ", 0, 5)
            self.area_msat_pix = self.add_field("msat pix: ", 0, 6)
            self.area_msat_coord = self.add_field("msat coord: ", 0, 7)

            self.area_gdal_pix = self.add_field("GDAL pix: ", 0, 8)
            self.area_gdal_coord = self.add_field("GDAL coord: ", 0, 9)

        def add_field(self, label: str, left: int, top: int):
            """
            Add a labeled field to the grid.

            Returns the label for the field
            """
            lbl = Gtk.Label(label=label)
            # lbl.set_justify(Gtk.Justification.RIGHT)
            lbl.set_xalign(1.0)
            self.attach(lbl, left, top, 1, 1)
            field = Gtk.Label()
            field.set_xalign(0.0)
            field.set_selectable(True)
            self.attach(field, left + 1, top, 1, 1)
            return field

#        def fmtll(self, lat, lon):
#            if abs(lat) > 90:
#                slat = "--"
#            else:
#                slat = "%.4f" % lat
#            if abs(lon) > 180:
#                slon = "--"
#            else:
#                slon = "%.4f" % lon
#            return "%s %s" % (slat, slon)
#
#        def on_position_changed(self, mapview, pos):
#            self.pos_pix.set_text("%d, %d" % (pos.px, pos.py))
#            self.pos_coord.set_text(self.fmtll(pos.lat, pos.lon))
#
#        def on_area_changed(self, mapview, a):
#            self.area_pix.set_text("%d, %d to %d, %d" % (a.pos1.px, a.pos1.py, a.pos2.px, a.pos2.py))
#            self.area_coord.set_text(
#                    "%s\n%s" % (self.fmtll(a.pos1.lat, a.pos1.lon), self.fmtll(a.pos2.lat, a.pos2.lon)))
#            latmin = min(a.pos1.lat, a.pos2.lat)
#            latmax = max(a.pos1.lat, a.pos2.lat)
#            lonmin = min(a.pos1.lon, a.pos2.lon)
#            lonmax = max(a.pos1.lon, a.pos2.lon)
#            self.area_msat_pix.set_text(
#                    "--area='%d,%d,%d,%d'" % (a.pos1.px, a.pos2.px-a.pos1.px, a.pos1.py, a.pos2.py-a.pos1.py))
#            self.area_msat_coord.set_text("--Area='%.4f %.4f %.4f %.4f" % (latmin, latmax, lonmin, lonmax))
#            self.area_gdal_pix.set_text(
#                    "%d %d %d %d" % (a.pos1.px, a.pos1.py, a.pos2.px-a.pos1.px, a.pos2.py-a.pos1.py))
#            self.area_gdal_coord.set_text("%.4f %.4f %.4f %.4f" % (lonmin, latmin, lonmax, latmax))

    # Load the image right now so we know about the aspect ratio
    w = MapWidget()
    w.load(args.file)

    info = ImageInfo()
#    w.connect("position-changed", info.on_position_changed)
#    w.connect("area-changed", info.on_area_changed)

    win = Gtk.Window(title=args.file)
    win.connect('destroy', Gtk.main_quit)
    win.set_size_request(500, 400)

    vbox = Gtk.VBox()
    win.add(vbox)

    toolbar = Gtk.Toolbar()
    tb_zoom_in = Gtk.ToolButton(stock_id=Gtk.STOCK_ZOOM_IN)
    tb_zoom_out = Gtk.ToolButton(stock_id=Gtk.STOCK_ZOOM_OUT)
    toolbar.insert(tb_zoom_in, 0)
    toolbar.insert(tb_zoom_out, 1)
    vbox.pack_start(toolbar, False, False, 0)

#    tb_zoom_in.connect("clicked", w.zoom_in)
#    tb_zoom_out.connect("clicked", w.zoom_out)

    imgframe = Gtk.Frame(label="Image")
    imgframe.add(w)

    infoframe = Gtk.Frame(label="Info")
    infoframe.add(info)

    box = Gtk.VPaned()
    box.pack1(imgframe, True, False)
    box.pack2(infoframe, True, False)
    box.set_position(300)

    vbox.pack_start(box, True, True, 0)

    win.show_all()

    Gtk.main()


def main():
    import argparse

    parser = argparse.ArgumentParser(description="Interactively display a satellite image.")
    parser.add_argument("file", help="file to display")
    args = parser.parse_args()

    start_app(args)


if __name__ == "__main__":
    main()
